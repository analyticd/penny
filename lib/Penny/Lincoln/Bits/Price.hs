{-# LANGUAGE DeriveGeneric, CPP, GeneralizedNewtypeDeriving #-}

module Penny.Lincoln.Bits.Price (
    From ( From, unFrom )
  , To ( To, unTo )
  , CountPerUnit ( CountPerUnit, unCountPerUnit )
  , Price ( from, to, countPerUnit )
  , convert
  , newPrice

#ifdef test
  , genPrice
  , tests
#endif
  ) where

import Data.Monoid (mconcat)
import qualified Penny.Lincoln.Equivalent as Ev
import Penny.Lincoln.Equivalent ((==~))
import qualified Penny.Lincoln.Bits.Open as O
import Penny.Lincoln.Bits.Qty (Qty, mult)
import GHC.Generics (Generic)
import qualified Data.Binary as B

#ifdef test
import Control.Applicative
import Test.QuickCheck (Arbitrary, Gen, arbitrary)
import qualified Test.QuickCheck as Q
import Test.Framework (Test, testGroup)
import Test.Framework.Providers.QuickCheck2 (testProperty)
#endif

newtype From = From { unFrom :: O.Commodity }
  deriving (Eq, Ord, Show, Generic
#ifdef test
  , Arbitrary)
#else
  )
#endif

instance B.Binary From

newtype To = To { unTo :: O.Commodity }
  deriving (Eq, Ord, Show, Generic
#ifdef test
  , Arbitrary
#endif
  )

instance B.Binary To

newtype CountPerUnit = CountPerUnit { unCountPerUnit :: Qty }
  deriving (Eq, Ord, Show, Generic
#ifdef test
  , Arbitrary
#endif
  )

instance Ev.Equivalent CountPerUnit where
  equivalent (CountPerUnit x) (CountPerUnit y) = x ==~ y
  compareEv (CountPerUnit x) (CountPerUnit y) = Ev.compareEv x y

instance B.Binary CountPerUnit

data Price = Price { from :: From
                   , to :: To
                   , countPerUnit :: CountPerUnit }
             deriving (Eq, Ord, Show, Generic)

#ifdef test
instance Arbitrary Price where
  arbitrary = do
    (f, t) <- Q.suchThat arbitrary (\(f, t) -> unFrom f /= unTo t)
    c <- arbitrary
    return $ Price f t c

-- | All Prices have from and to commodities that are different.
prop_price :: Price -> Bool
prop_price (Price f t _) = unFrom f /= unTo t

newtype DifferentFromTo = DifferentFromTo (From, To)
  deriving (Eq, Show)

instance Arbitrary DifferentFromTo where
  arbitrary = fmap DifferentFromTo $
              Q.suchThat arbitrary (\(f, t) -> unFrom f /= unTo t)

newtype SameFromTo = SameFromTo (From, To)
  deriving (Eq, Show)

instance Arbitrary SameFromTo where
  arbitrary = fmap (\c -> SameFromTo (From c, To c)) arbitrary

-- | genPrice generates valid prices
prop_genPrice :: DifferentFromTo -> Gen Bool
prop_genPrice (DifferentFromTo (f, t)) = do
  p <- genPrice f t
  return $ prop_price p

-- | genPrice does not generate invalid prices
prop_genPriceNoInvalid :: SameFromTo -> Gen Bool
prop_genPriceNoInvalid (SameFromTo f t) = 

-- | Generates a price. The given From and To commodities are used;
-- however, they must be different commodities. The CountPerUnit is
-- generated by arbitrary. /This function is partial/. It applies
-- 'error' if the given From and To commodities are equal.
genPrice :: From -> To -> Gen Price
genPrice f t = if unFrom f == unTo t
               then error "genPrice: commodites equal"
               else (Price f t) <$> arbitrary

#endif

instance B.Binary Price

-- | Two Price are equivalent if the From and To are equal and the
-- CountPerUnit is equivalent.

instance Ev.Equivalent Price where
  equivalent (Price xf xt xc) (Price yf yt yc) =
    xf == yf && xt == yt && xc ==~ yc

  compareEv (Price xf xt xc) (Price yf yt yc) = mconcat
    [ compare xf yf
    , compare xt yt
    , Ev.compareEv xc yc
    ]

-- | Convert an amount from the From price to the To price. Fails if
-- the From commodity in the Price is not the same as the commodity in
-- the Amount.
convert :: Price -> O.Amount -> Maybe O.Amount
convert p (O.Amount q c) =
  if (unFrom . from $ p) /= c
  then Nothing
  else let q' = q `mult` (unCountPerUnit . countPerUnit $ p)
       in Just (O.Amount q' (unTo . to $ p))

-- | Succeeds only if From and To are different commodities.
newPrice :: From -> To -> CountPerUnit -> Maybe Price
newPrice f t cpu =
  if unFrom f == unTo t
  then Nothing
  else Just $ Price f t cpu

#ifdef test

-- | newPrice succeeds if the From and To are different.

#endif

tests :: Test
tests = testGroup "Penny.Lincoln.Bits.Price"
  [ testProperty "prop_price" prop_price
  , testProperty "prop_genPrice" prop_genPrice
  ]
